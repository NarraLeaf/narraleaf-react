import { Timeline } from "@lib/game/player/Tasks";
import { Action } from "./action";
import { randId } from "@lib/util/data";
import { LiveGameEventToken } from "../types";
import { LogicAction } from "../game";

export type ActionHistory<T extends Array<unknown> = any> = {
    action: Action;
    timeline?: Timeline;
    args: T;
    id: string;
    undo?: (...args: T) => void;
}

export class ActionHistoryManager {
    private history: ActionHistory<any>[] = [];
    private readonly maxHistorySize: number;
    private hooks: {
        onUndo: ((affected: ActionHistory<any>[]) => void)[];
        onHistoryLimit: ((removed: ActionHistory<any>[]) => void)[];
    } = {
        onUndo: [],
        onHistoryLimit: [],
    };

    constructor(maxHistorySize: number = 100) {
        this.maxHistorySize = maxHistorySize;
    }

    /**
     * Push an action to the history
     */
    public push<T extends Array<any> = Array<any>>(action: Action, onUndo?: (...args: T) => void, args?: T, timeline?: Timeline): {id: string} {
        const id = randId(6);
        this.history.push({action, id, args, undo: onUndo, timeline});
        
        // Check if the history size exceeds the limit
        if (this.history.length > this.maxHistorySize) {
            const removed = this.history.splice(0, this.history.length - this.maxHistorySize);
            this.hooks.onHistoryLimit.forEach(cb => cb(removed));
        }
        
        return {id};
    }

    /**
     * Undo all actions until the given id
     * 
     * If the given id is not found, nothing will happen
     * @param id random id generated by push
     */
    public undoUntil(id: string): LogicAction.Actions | null {
        let index = -1;
        for (let i = this.history.length - 1; i >= 0; i--) {
            if (this.history[i].id === id) {
                index = i;
                break;
            }
        }
        if (index === -1) {
            return null;
        }

        const affected: ActionHistory<any>[] = [];
        for (let i = this.history.length - 1; i >= index; i--) {
            if (this.history[i].timeline && !this.history[i].timeline!.isSettled) {
                this.history[i].timeline!.abort();
            }
            this.history[i].undo?.(...(this.history[i].args || []));
            affected.push(this.history[i]);
        }

        this.history.splice(index);
        this.hooks.onUndo.forEach(cb => cb(affected));
        return null;
    }

    public undo(): LogicAction.Actions | null {
        const last = this.history.pop();
        if (last) {
            if (last.timeline && !last.timeline.isSettled) {
                last.timeline.abort();
            }
            last.undo?.(...last.args);
            this.hooks.onUndo.forEach(cb => cb([last]));
            return last.action as LogicAction.Actions;
        }
        return null;
    }

    public onUndo(callback: (affected: ActionHistory<any>[]) => void): LiveGameEventToken {
        this.hooks.onUndo.push(callback);
        return {
            cancel: () => this.offUndo(callback),
        };
    }

    public offUndo(callback: (affected: ActionHistory<any>[]) => void): void {
        this.hooks.onUndo = this.hooks.onUndo.filter(cb => cb !== callback);
    }

    public getHistory(): ActionHistory<any>[] {
        return this.history;
    }

    public onHistoryLimit(callback: (removed: ActionHistory<any>[]) => void): LiveGameEventToken {
        this.hooks.onHistoryLimit.push(callback);
        return {
            cancel: () => this.offHistoryLimit(callback),
        };
    }

    public offHistoryLimit(callback: (removed: ActionHistory<any>[]) => void): void {
        this.hooks.onHistoryLimit = this.hooks.onHistoryLimit.filter(cb => cb !== callback);
    }
}